{\rtf1\ansi\ansicpg1252\cocoartf2822
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red202\green202\blue202;\red23\green24\blue24;}
{\*\expandedcolortbl;;\cssrgb\c83137\c83137\c83137;\cssrgb\c11765\c12157\c12549;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
<!DOCTYPE html>\
<html lang="it">\
<head>\
    <meta charset="UTF-8">\
    <meta name="viewport" content="width=device-width, initial-scale=1.0">\
    <title>Flappy Fantasma</title>\
    <!-- Tailwind CSS CDN per uno stile facile e responsivo -->\
    <script src="https://cdn.tailwindcss.com"></script>\
    <style>\
        body \{\
            font-family: 'Inter', sans-serif; /* Font Inter */\
            background-color: #1a202c; /* Colore di sfondo scuro */\
            display: flex;\
            flex-direction: column;\
            justify-content: center;\
            align-items: center;\
            min-height: 100vh;\
            margin: 0;\
            color: #e2e8f0; /* Testo chiaro */\
            overflow: hidden; /* Evita lo scrolling */\
        \}\
        canvas \{\
            /* Lo sfondo \'e8 disegnato via JS per l'effetto stellato */\
            border: 2px solid #e2e8f0; /* Bordo chiaro */\
            border-radius: 8px; /* Bordi arrotondati */\
            display: block;\
            touch-action: none; /* Impedisce lo scrolling sui dispositivi touch */\
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5); /* Effetto neon verde */\
        \}\
        .game-container \{\
            display: flex;\
            flex-direction: column;\
            align-items: center;\
            gap: 20px;\
            padding: 20px;\
        \}\
        .score-board \{\
            display: flex;\
            justify-content: center;\
            width: 100%;\
            max-width: 600px; /* Adatta alla larghezza del canvas */\
            font-size: 2.5rem;\
            font-weight: bold;\
            margin-bottom: 10px;\
            color: #e2e8f0;\
        \}\
        .message-box \{\
            position: absolute;\
            top: 50%;\
            left: 50%;\
            transform: translate(-50%, -50%);\
            background-color: rgba(0, 0, 0, 0.9); /* Sfondo pi\'f9 scuro per il messaggio */\
            border: 2px solid #e2e8f0;\
            border-radius: 10px;\
            padding: 30px;\
            text-align: center;\
            z-index: 1000;\
            display: none;\
            flex-direction: column;\
            gap: 20px;\
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);\
        \}\
        .message-box button \{\
            background-color: #4a5568;\
            color: #e2e8f0;\
            padding: 12px 25px; /* Pulsante pi\'f9 grande */\
            border-radius: 8px; /* Bordi pi\'f9 arrotondati */\
            cursor: pointer;\
            transition: background-color 0.3s ease, transform 0.2s ease;\
            font-size: 1.2rem;\
            font-weight: bold;\
            border: none;\
            box-shadow: 0 4px #2d3748; /* Ombra per effetto 3D */\
        \}\
        .message-box button:hover:not(:disabled) \{ /* Aggiunto :not(:disabled) */\
            background-color: #6a778e;\
            transform: translateY(-2px);\
            box-shadow: 0 6px #2d3748;\
        \}\
        .message-box button:active:not(:disabled) \{ /* Aggiunto :not(:disabled) */\
            transform: translateY(2px);\
            box-shadow: 0 2px #2d3748;\
        \}\
        .message-box button:disabled \{ /* Stile per pulsante disabilitato */\
            background-color: #2d3748;\
            cursor: not-allowed;\
            opacity: 0.7;\
        \}\
        .controls-info \{\
            font-size: 1rem;\
            color: #a0aec0;\
            text-align: center;\
            margin-top: 10px;\
        \}\
    </style>\
</head>\
<body>\
    <div class="game-container">\
        <h1 class="text-4xl font-extrabold text-white mb-4">Flappy Fantasma</h1>\
        <div class="score-board">\
            <span id="score">Punti: 0</span>\
        </div>\
        <canvas id="gameCanvas"></canvas>\
        <div class="controls-info">\
            <p>Clicca, tocca lo schermo o premi 'F' per far volare il fantasma!</p>\
        </div>\
    </div>\
\
    <div id="messageBox" class="message-box">\
        <div id="messageText" class="text-2xl font-bold text-white"></div>\
        <button id="startButton">Inizia Gioco</button>\
    </div>\
\
    <script>\
        // Variabili globali fornite dall'ambiente Canvas (non utilizzate in questo gioco, ma mantenute per consistenza)\
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';\
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : \{\};\
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null; \
\
        // Costanti di gioco\
        const CANVAS_WIDTH = 600;\
        const CANVAS_HEIGHT = 400;\
        const GAME_OVERALL_SLOWDOWN_FACTOR = 0.80; // Velocit\'e0 generale del gioco ridotta del 20%\
        \
        // Valori base per le meccaniche di gioco (prima di eventuali moltiplicatori generali o specifici per livello)\
        const BASE_GRAVITY = (((0.5 * 0.7) * 0.84) * 0.90); \
        const BASE_FLAP_STRENGTH = -8 * 0.8; \
        // Aumentato il fantasma protagonista del 20%\
        const PLAYER_WIDTH = (40 / 2) * 1.20; \
        const PLAYER_HEIGHT = (30 / 2) * 1.20; \
        const PIPE_WIDTH = 60;\
        // Spazio tra il tubo superiore e inferiore: (((120 * 1.15) * 0.80) * 1.09) * 0.90\
        const PIPE_GAP = 108.3024; // Ridotto del 10%\
        const BASE_PIPE_SPEED = 3 * (1 - 0.13); \
        const PIPE_INTERVAL = 1500; \
        // Ritardo per dare tempo all'animazione di completarsi, aggiornato a 2000ms\
        const WIN_MESSAGE_DELAY = 2000; \
\
        const BASE_PINK_GHOST_SPEED = 2; // Velocit\'e0 base per il fantasma rosa nell'animazione di vittoria\
        const CHILD_GHOST_SIZE_FACTOR = 0.6; // I fantasmi figli sono al 60% della dimensione dei fantasmi principali\
\
        const LEVEL_GOALS = [10, 40, 100]; // Obiettivi di punteggio per Livello 1, 2, 3\
        const LEVEL_SPEED_INCREASE_FACTOR = 1.05; // Ogni livello successivo \'e8 il 5% pi\'f9 veloce\
\
        const PIPE_COLORS_PALETTE = [\
            '#2d3748', // Grigio scuro (originale)\
            '#4299e1', // Blu\
            '#38a169', // Verde\
            '#e53e3e', // Rosso\
            '#9f7aea', // Viola\
            '#ecc94b', // Giallo\
            '#ed8936'  // Arancione\
        ];\
\
        // Riferimenti agli elementi DOM\
        const canvas = document.getElementById('gameCanvas');\
        const ctx = canvas.getContext('2d');\
        const scoreElem = document.getElementById('score');\
        const messageBox = document.getElementById('messageBox');\
        const messageText = document.getElementById('messageText');\
        const startButton = document.getElementById('startButton');\
\
        // Variabili di velocit\'e0 dinamiche (impostate in startGame in base al livello)\
        let currentGravity;\
        let currentFlapStrength;\
        let currentPipeSpeed;\
        let currentStarScrollSpeed;\
        let currentPinkGhostSpeed;\
        let currentPipeColor; // Conterr\'e0 il colore scelto casualmente per i tubi\
\
        let player = \{\
            x: 50,\
            y: CANVAS_HEIGHT / 2 - PLAYER_HEIGHT / 2,\
            dy: 0 // Velocit\'e0 verticale\
        \};\
\
        let pipes = [];\
        let score = 0;\
        let lives = 3; // Numero di vite iniziali, ridotto a 3\
        let animationFrameId;\
\
        let stars = []; // Array per le stelle\
        const NUM_SMALL_STARS = 150; // Numero di stelle piccole\
        const NUM_LARGE_STARS = Math.floor(NUM_SMALL_STARS * 0.10); // 10% di stelle grandi (15 stelle)\
        const MAX_SMALL_STAR_OUTER_RADIUS = 2; // Raggio esterno massimo per le stelle piccole\
        const MAX_LARGE_STAR_OUTER_RADIUS = MAX_SMALL_STAR_OUTER_RADIUS * 2; // Raggio esterno massimo per le stelle grandi\
\
        // Nuovi elementi per l'animazione della schermata di vittoria\
        let pinkGhost = \{ x: 0, y: 0, speed: 0, activated: false \}; // Fantasma rosa per la schermata di vittoria, la velocit\'e0 verr\'e0 impostata dinamicamente\
        let hearts = []; // Array per memorizzare le particelle a forma di cuore\
        let winMessageDelayTimer = null; // Timer per controllare quando appare la casella del messaggio di vittoria\
        let childGhosts = []; // Per l'animazione della vittoria finale\
\
        let currentLevel = 1;\
\
        // Nuovi stati del gioco per una gestione pi\'f9 precisa\
        const GAME_STATE = \{\
            IDLE: 'idle', // Schermata iniziale, in attesa di "Inizia Gioco"\
            PENDING_START: 'pending_start', // Gioco configurato, in attesa del primo flap per iniziare a giocare\
            PLAYING: 'playing', // Il gioco \'e8 in corso\
            LEVEL_WIN_ANIMATION: 'level_win_animation', // Animazione di vittoria di livello in corso\
            FINAL_WIN_ANIMATION: 'final_win_animation', // Animazione di vittoria finale in corso\
            GAME_OVER_MESSAGE: 'game_over_message', // Messaggio di Game Over (vite rimanenti), in attesa di input\
            RESTART_COUNTDOWN: 'restart_countdown' // Game Over (zero vite), conto alla rovescia per il riavvio completo\
        \};\
\
        let gameStatus = GAME_STATE.IDLE; // Inizializza con lo stato di inattivit\'e0\
        let lastPipeTime = 0; // Inizializzazione per evitare ReferenceError\
\
\
        /**\
         * Crea una nuova particella a forma di cuore.\
         * @returns \{object\} Un oggetto cuore con posizione, dimensione, velocit\'e0 e opacit\'e0.\
         */\
        function createHeart() \{\
            const size = Math.random() * 8 + 4; // Dimensione tra 4 e 12\
            return \{\
                x: Math.random() * CANVAS_WIDTH,\
                y: -size, // Inizia sopra il canvas\
                size: size,\
                dx: (Math.random() - 0.5) * 1, // Lieve deriva orizzontale\
                dy: Math.random() * 2 + 1, // Velocit\'e0 di caduta\
                opacity: 1,\
                color: '255, 105, 180' // Colore rosa in RGB\
            \};\
        \}\
\
        /**\
         * Disegna una particella a forma di cuore stilizzata.\
         * @param \{number\} x - Coordinata X del centro del cuore.\
         * @param \{number\} y - Coordinata Y del centro del cuore.\
         * @param \{number\} size - Dimensione del cuore.\
         * @param \{string\} color - Colore del cuore (es. '255, 105, 180' per rosa).\
         * @param \{number\} opacity - Opacit\'e0 del cuore (0-1).\
         */\
        function drawHeart(x, y, size, color, opacity) \{\
            ctx.fillStyle = `rgba($\{color\}, $\{opacity\})`;\
            ctx.beginPath();\
            ctx.moveTo(x, y + size / 4); // Inizia dal punto in basso del cuore\
            ctx.bezierCurveTo(\
                x + size / 2, y - size / 2,    // Punto di controllo 1 (in alto a destra)\
                x + size, y,                 // Punto di controllo 2 (a met\'e0 a destra)\
                x, y + size                  // Punto finale (di nuovo il punto in basso)\
            );\
            ctx.bezierCurveTo(\
                x - size, y,                 // Punto di controllo 3 (a met\'e0 a sinistra)\
                x - size / 2, y - size / 2,    // Punto di controllo 4 (in alto a sinistra)\
                x, y + size / 4              // Punto finale (di nuovo l'inizio)\
            );\
            ctx.closePath();\
            ctx.fill();\
        \}\
\
        /**\
         * Disegna una stella a 5 punte.\
         * @param \{object\} ctx - Il contesto di rendering 2D del canvas.\
         * @param \{number\} cx - Coordinata X del centro della stella.\
         * @param \{number\} cy - Coordinata Y del centro della stella.\
         * @param \{number\} outerRadius - Raggio esterno della stella.\
         * @param \{number\} innerRadius - Raggio interno della stella.\
         * @param \{string\} color - Colore della stella.\
         * @param \{number\} rotation - Rotazione della stella in radianti.\
         */\
        function drawStar(ctx, cx, cy, outerRadius, innerRadius, color, rotation = 0) \{\
            let rot = rotation;\
            let x, y;\
            ctx.fillStyle = color;\
            ctx.beginPath();\
\
            for (let i = 0; i < 5; i++) \{\
                x = cx + Math.cos(rot) * outerRadius;\
                y = cy + Math.sin(rot) * outerRadius;\
                ctx.lineTo(x, y);\
                rot += Math.PI / 5;\
\
                x = cx + Math.cos(rot) * innerRadius;\
                y = cy + Math.sin(rot) * innerRadius;\
                ctx.lineTo(x, y);\
                rot += Math.PI / 5;\
            \}\
            ctx.closePath();\
            ctx.fill();\
        \}\
\
        /**\
         * Genera posizioni e propriet\'e0 casuali per le stelle nello sfondo.\
         */\
        function generateStars() \{\
            stars = [];\
            // Genera stelle piccole\
            for (let i = 0; i < NUM_SMALL_STARS; i++) \{\
                stars.push(\{\
                    x: Math.random() * CANVAS_WIDTH,\
                    y: Math.random() * CANVAS_HEIGHT,\
                    outerRadius: Math.random() * (MAX_SMALL_STAR_OUTER_RADIUS - 0.5) + 0.5, // Raggio esterno casuale tra 0.5 e MAX_SMALL_STAR_OUTER_RADIUS\
                    innerRadius: (Math.random() * 0.5 + 0.2) * (Math.random() * (MAX_SMALL_STAR_OUTER_RADIUS - 0.5) + 0.5), // Raggio interno proporzionale\
                    speed: Math.random() * 0.5 + 0.1, // Velocit\'e0 casuale per l'effetto parallasse\
                    rotation: Math.random() * Math.PI * 2, // Rotazione casuale in radianti\
                    isLarge: false // Contrassegna come stella piccola\
                \});\
            \}\
            // Genera stelle grandi\
            for (let i = 0; i < NUM_LARGE_STARS; i++) \{\
                stars.push(\{\
                    x: Math.random() * CANVAS_WIDTH,\
                    y: Math.random() * CANVAS_HEIGHT,\
                    outerRadius: Math.random() * (MAX_LARGE_STAR_OUTER_RADIUS - MAX_SMALL_STAR_OUTER_RADIUS) + MAX_SMALL_STAR_OUTER_RADIUS, // Raggio esterno casuale tra MAX_SMALL_STAR_OUTER_RADIUS e MAX_LARGE_STAR_OUTER_RADIUS\
                    innerRadius: (Math.random() * 0.5 + 0.2) * (Math.random() * (MAX_LARGE_STAR_OUTER_RADIUS - MAX_SMALL_STAR_OUTER_RADIUS) + MAX_SMALL_STAR_OUTER_RADIUS),\
                    speed: (Math.random() * 0.5 + 0.1) * 1.5, // Le stelle pi\'f9 grandi si muovono un po' pi\'f9 velocemente\
                    rotation: Math.random() * Math.PI * 2,\
                    isLarge: true // Contrassegna come stella grande\
                \});\
            \}\
        \}\
\
        /**\
         * Disegna la forma di un fantasma.\
         * @param \{number\} x - Coordinata X dell'angolo superiore sinistro.\
         * @param \{number\} y - Coordinata Y del centro del fantasma.\
         * @param \{number\} width - Larghezza del fantasma.\
         * @param \{number\} height - Altezza del fantasma.\
         * @param \{string\} color - Colore del fantasma.\
         * @param \{string\} [direction='right'] - Direzione in cui guarda il fantasma ('left' o 'right').\
         */\
        function drawGhost(x, y, width, height, color, direction = 'right') \{\
            ctx.fillStyle = color;\
            ctx.beginPath();\
            // Parte superiore arrotondata\
            ctx.arc(x + width / 2, y + height / 3, width / 2, Math.PI, 0, false);\
            // Lati\
            ctx.lineTo(x + width, y + height);\
            // Parte inferiore frastagliata\
            ctx.lineTo(x + width * 5 / 6, y + height * 0.9);\
            ctx.lineTo(x + width * 4 / 6, y + height);\
            ctx.lineTo(x + width * 3 / 6, y + height * 0.9);\
            ctx.lineTo(x + width * 2 / 6, y + height);\
            ctx.lineTo(x + width * 1 / 6, y + height * 0.9);\
            ctx.lineTo(x, y + height);\
            ctx.closePath();\
            ctx.fill();\
\
            // Occhi (bianchi) - ingranditi e spostati in base alla direzione\
            const eyeRadius = width * 0.15; \
            ctx.fillStyle = 'white';\
            ctx.beginPath();\
            if (direction === 'right') \{\
                ctx.arc(x + width * 0.47, y + height * 0.38, eyeRadius, 0, Math.PI * 2, false); // Occhio sinistro (relativo)\
                ctx.arc(x + width * 0.82, y + height * 0.38, eyeRadius, 0, Math.PI * 2, false); // Occhio destro (relativo)\
            \} else \{ // direction === 'left'\
                ctx.arc(x + width * 0.18, y + height * 0.38, eyeRadius, 0, Math.PI * 2, false); // Occhio destro (relativo)\
                ctx.arc(x + width * 0.53, y + height * 0.38, eyeRadius, 0, Math.PI * 2, false); // Occhio sinistro (relativo)\
            \}\
            ctx.fill();\
\
            // Pupille (nera) - ingrandite e spostate in base alla direzione\
            const pupilRadius = width * 0.08; \
            ctx.fillStyle = 'black';\
            ctx.beginPath();\
            if (direction === 'right') \{\
                ctx.arc(x + width * 0.52, y + height * 0.38, pupilRadius, 0, Math.PI * 2, false); // Pupilla sinistra (relativa)\
                ctx.arc(x + width * 0.77, y + height * 0.38, pupilRadius, 0, Math.PI * 2, false); // Pupilla destra (relativa)\
            \} else \{ // direction === 'left'\
                ctx.arc(x + width * 0.23, y + height * 0.38, pupilRadius, 0, Math.PI * 2, false); // Pupilla destra (relativa)\
                ctx.arc(x + width * 0.48, y + height * 0.38, pupilRadius, 0, Math.PI * 2, false); // Pupilla sinistra (relativa)\
            \}\
            ctx.fill();\
        \}\
\
        /**\
         * Disegna un tubo.\
         * @param \{object\} pipe - L'oggetto tubo.\
         */\
        function drawPipe(pipe) \{\
            ctx.fillStyle = currentPipeColor; /* Colore condotta (scelto casualmente) */\
            // Tubo superiore\
            ctx.roundRect(pipe.x, 0, pipe.width, pipe.height, 5);\
            ctx.fill();\
            // Tubo inferiore\
            ctx.roundRect(pipe.x, pipe.height + pipe.gap, pipe.width, CANVAS_HEIGHT - (pipe.height + pipe.gap), 5);\
            ctx.fill();\
        \}\
\
        /**\
         * Disegna tutti gli elementi del gioco sul canvas in base allo stato del gioco.\
         */\
        function draw() \{\
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT); // Pulisci l'intero canvas\
\
            // Disegna lo sfondo del cielo stellato SEMPRE come primo strato\
            ctx.fillStyle = '#1a202c'; \
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\
\
            // Aggiorna e disegna le stelle per l'effetto parallasse SEMPRE\
            ctx.fillStyle = 'white';\
            stars.forEach(star => \{\
                star.x -= currentStarScrollSpeed * star.speed; \
                if (star.x + star.outerRadius < 0) \{ \
                    star.x = CANVAS_WIDTH + star.outerRadius + Math.random() * 50; // Ri-appare fuori schermo a destra\
                    star.y = Math.random() * CANVAS_HEIGHT; \
                    star.rotation = Math.random() * Math.PI * 2;\
                    \
                    if (star.isLarge) \{ // Se era una stella grande, rigenerala come grande\
                        star.outerRadius = Math.random() * (MAX_LARGE_STAR_OUTER_RADIUS - 0.5) + 0.5;\
                        star.innerRadius = (Math.random() * 0.5 + 0.2) * star.outerRadius;\
                        star.speed = Math.random() * 0.5 + 0.1;\
                    \} else \{ // Era una stella piccola\
                        star.outerRadius = Math.random() * (MAX_SMALL_STAR_OUTER_RADIUS - 0.5) + 0.5;\
                        star.innerRadius = (Math.random() * 0.5 + 0.2) * star.outerRadius;\
                        star.speed = Math.random() * 0.5 + 0.1;\
                    \}\
                \}\
                drawStar(ctx, star.x, star.y, star.outerRadius, star.innerRadius, 'white', star.rotation); // Passa ctx a drawStar\
            \});\
\
            // Disegna gli elementi specifici del gioco (tubi, giocatore, fantasmi dell'animazione di vittoria) condizionalmente\
            if (gameStatus === GAME_STATE.PLAYING || gameStatus === GAME_STATE.IDLE || gameStatus === GAME_STATE.PENDING_START || gameStatus === GAME_STATE.GAME_OVER_MESSAGE || gameStatus === GAME_STATE.RESTART_COUNTDOWN) \{\
                pipes.forEach(drawPipe); // Disegna tutti i tubi\
                drawGhost(player.x, player.y, PLAYER_WIDTH, PLAYER_HEIGHT, '#e53e3e', 'right'); // Disegna il fantasma rosso\
\
            \} else if (gameStatus === GAME_STATE.LEVEL_WIN_ANIMATION || gameStatus === GAME_STATE.FINAL_WIN_ANIMATION) \{\
                // Disegna il fantasma giocatore centrato\
                const centerX = CANVAS_WIDTH / 2 - PLAYER_WIDTH / 2;\
                const centerY = CANVAS_HEIGHT / 2 - PLAYER_HEIGHT / 2;\
                drawGhost(centerX, centerY, PLAYER_WIDTH, PLAYER_HEIGHT, '#e53e3e', 'right'); // Il fantasma rosso guarda a destra\
\
                // Disegna il fantasma rosa (la direzione dipende dalla sua posizione rispetto al fantasma rosso)\
                // Se il fantasma rosa \'e8 alla destra del fantasma rosso, deve guardare a sinistra per "guardarlo"\
                drawGhost(pinkGhost.x, pinkGhost.y, PLAYER_WIDTH, PLAYER_HEIGHT, 'pink', 'left'); \
                \
                // Disegna i fantasmi figli per l'animazione della vittoria finale\
                if (gameStatus === GAME_STATE.FINAL_WIN_ANIMATION) \{\
                    childGhosts.forEach(child => \{\
                        // Anche i fantasmi figli dovrebbero guardare a sinistra in questa animazione\
                        drawGhost(child.x, child.y, PLAYER_WIDTH * CHILD_GHOST_SIZE_FACTOR, PLAYER_HEIGHT * CHILD_GHOST_SIZE_FACTOR, child.color, 'left');\
                    \});\
                \}\
\
                // Disegna i cuoricini\
                hearts.forEach(heart => \{\
                    drawHeart(heart.x, heart.y, heart.size, heart.color, heart.opacity);\
                \});\
            \}\
        \}\
\
        /**\
         * Aggiorna lo stato del gioco.\
         */\
        function update() \{\
            // La logica di aggiornamento si esegue solo se il gioco \'e8 nello stato PLAYING\
            if (gameStatus !== GAME_STATE.PLAYING) return;\
\
            // Aggiorna la posizione del giocatore\
            player.dy += currentGravity;\
            player.y += player.dy;\
\
            // Limita la posizione del giocatore entro i bordi del canvas\
            if (player.y < 0) \{\
                player.y = 0;\
                player.dy = 0;\
            \}\
            if (player.y + PLAYER_HEIGHT > CANVAS_HEIGHT) \{\
                player.y = CANVAS_HEIGHT - PLAYER_HEIGHT;\
                endGame('gameOver'); // Game over se tocca il suolo\
                return; // Esci per prevenire ulteriori aggiornamenti dopo il game over\
            \}\
\
            // Sposta e genera tubi\
            const currentTime = Date.now();\
            if (currentTime - lastPipeTime > PIPE_INTERVAL) \{\
                generatePipe();\
                lastPipeTime = currentTime;\
            \}\
\
            for (let i = 0; i < pipes.length; i++) \{\
                let pipe = pipes[i];\
                pipe.x -= currentPipeSpeed;\
\
                // Controlla il punteggio\
                if (pipe.x + pipe.width < player.x && !pipe.passed) \{\
                    score++;\
                    scoreElem.textContent = `Punti: $\{score\} / $\{LEVEL_GOALS[currentLevel - 1]\} (Livello $\{currentLevel\}) Vite: $\{lives\}`;\
                    pipe.passed = true;\
                    // Controlla la condizione di vittoria per il livello attuale\
                    if (score >= LEVEL_GOALS[currentLevel - 1]) \{\
                        if (currentLevel < LEVEL_GOALS.length) \{\
                            endGame('levelWin'); // Livello completato\
                        \} else \{\
                            endGame('finalWin'); // Vittoria finale\
                        \}\
                        return; // Esci per evitare ulteriori aggiornamenti dopo la vittoria/completamento del livello\
                    \}\
                \}\
\
                // Rimuovi i tubi fuori schermo\
                if (pipe.x + pipe.width < 0) \{\
                    pipes.splice(i, 1);\
                    i--; // Decrementa l'indice per compensare la rimozione\
                \}\
\
                // Controlla le collisioni con i tubi\
                if (\
                    player.x < pipe.x + pipe.width &&\
                    player.x + PLAYER_WIDTH > pipe.x &&\
                    (player.y < pipe.height || player.y + PLAYER_HEIGHT > pipe.height + pipe.gap)\
                ) \{\
                    endGame('gameOver'); // Collisione con il tubo\
                    return; // Esci per evitare ulteriori aggiornamenti dopo il game over\
                \}\
            \}\
        \}\
\
        /**\
         * Aggiorna gli elementi specifici dell'animazione della schermata di vittoria.\
         */\
        function updateWinScreen() \{\
            const centerX = CANVAS_WIDTH / 2 - PLAYER_WIDTH / 2;\
            const centerY = CANVAS_HEIGHT / 2 - PLAYER_HEIGHT / 2;\
\
            const redGhostX = centerX; \
            const redGhostY = centerY;\
\
            // Posizione target per il fantasma rosa per fermarsi a destra del fantasma rosso, guardando a sinistra\
            const pinkGhostTargetX = redGhostX + PLAYER_WIDTH + 5; \
\
            let ghostsAnimationDone = true;\
\
            // Aggiorna la posizione del fantasma rosa (si muove sia per Level Win che per Final Win)\
            if (!pinkGhost.activated) \{\
                // Si muove da destra a sinistra (x diminuisce)\
                if (pinkGhost.x > pinkGhostTargetX) \{\
                    pinkGhost.x -= currentPinkGhostSpeed;\
                    ghostsAnimationDone = false; // Il fantasma rosa si sta ancora muovendo\
                \} else \{\
                    pinkGhost.x = pinkGhostTargetX;\
                    pinkGhost.activated = true; // Il fantasma rosa \'e8 arrivato\
                \}\
            \}\
            \
            // I fantasmi figli seguono il fantasma rosa (solo per FINAL_WIN_ANIMATION)\
            // I fantasmi figli si muovono da destra a sinistra e si fermano a destra del fantasma rosa\
            if (gameStatus === GAME_STATE.FINAL_WIN_ANIMATION) \{\
                childGhosts.forEach((child) => \{\
                    // Si muovono solo se il fantasma rosa \'e8 arrivato e il figlio non \'e8 ancora a destinazione\
                    if (pinkGhost.activated && child.x > child.targetX) \{ // I figli si muovono a sinistra\
                        child.x -= child.speed;\
                        ghostsAnimationDone = false; // I figli si stanno ancora muovendo\
                    \} else \{\
                        child.x = child.targetX;\
                    \}\
                    // Oscillazione verticale per i figli\
                    child.y = redGhostY + Math.sin(Date.now() * 0.005 + child.timeOffset) * 5;\
                \});\
            \}\
            \
            // Aggiorna i cuoricini\
            for (let i = 0; i < hearts.length; i++) \{\
                const heart = hearts[i];\
                heart.y += heart.dy;\
                heart.x += heart.dx;\
                heart.opacity -= 0.005;\
\
                if (heart.y > CANVAS_HEIGHT + heart.size || heart.opacity <= 0) \{\
                    hearts.splice(i, 1);\
                    i--;\
                \}\
            \}\
\
            // Controlla se tutte le animazioni visive sono veramente complete\
            let allVisualAnimationsComplete = ghostsAnimationDone && (hearts.length === 0);\
\
            // Avvia il timer di ritardo solo dopo che tutte le animazioni visive sono complete\
            if (allVisualAnimationsComplete && winMessageDelayTimer === null) \{\
                winMessageDelayTimer = Date.now();\
            \}\
\
            // Mostra la casella del messaggio solo dopo il ritardo\
            if (winMessageDelayTimer !== null && Date.now() - winMessageDelayTimer > WIN_MESSAGE_DELAY) \{\
                messageBox.style.display = 'flex';\
                startButton.disabled = false;\
                \
                if (gameStatus === GAME_STATE.FINAL_WIN_ANIMATION) \{\
                    messageText.textContent = `Vittoria Finale! Hai completato tutti i livelli con $\{score\} punti! Premi 'F' o tocca per giocare di nuovo.`;\
                    startButton.textContent = "Gioca di nuovo";\
                \} else if (gameStatus === GAME_STATE.LEVEL_WIN_ANIMATION) \{\
                    messageText.textContent = `Livello $\{currentLevel - 1\} Completato! Punti: $\{score\}. Premi 'F' o tocca per il Livello $\{currentLevel\}!`;\
                    startButton.textContent = "Prossimo Livello";\
                \}\
                winMessageDelayTimer = null;\
                gameStatus = GAME_STATE.PENDING_START; // Transizione allo stato in sospeso in attesa di un flap\
            \}\
        \}\
\
        /**\
         * Genera una nuova coppia di tubi.\
         */\
        function generatePipe() \{\
            // Altezza casuale per il tubo superiore, lasciando spazio per il tubo inferiore e lo spazio\
            const minHeight = 50;\
            const maxHeight = CANVAS_HEIGHT - PIPE_GAP - minHeight;\
            const topPipeHeight = Math.floor(Math.random() * (maxHeight - minHeight + 1)) + minHeight;\
\
            pipes.push(\{\
                x: CANVAS_WIDTH,\
                height: topPipeHeight,\
                gap: PIPE_GAP,\
                width: PIPE_WIDTH,\
                passed: false // Per tracciare il punteggio\
            \});\
        \}\
\
        /**\
         * Il ciclo principale del gioco.\
         */\
        function gameLoop() \{\
            switch (gameStatus) \{\
                case GAME_STATE.PLAYING:\
                    update();\
                    draw();\
                    break;\
                case GAME_STATE.LEVEL_WIN_ANIMATION:\
                case GAME_STATE.FINAL_WIN_ANIMATION:\
                    updateWinScreen();\
                    draw();\
                    break;\
                case GAME_STATE.IDLE:\
                case GAME_STATE.PENDING_START:\
                case GAME_STATE.GAME_OVER_MESSAGE:\
                case GAME_STATE.RESTART_COUNTDOWN:\
                    draw(); // Disegna solo la scena statica o i messaggi\
                    break;\
            \}\
            animationFrameId = requestAnimationFrame(gameLoop);\
        \}\
\
        /**\
         * Resetta il gioco per una nuova partita completa (score, vite, livello).\
         */\
        function resetGameForNewPlay() \{\
            player = \{\
                x: 50,\
                y: CANVAS_HEIGHT / 2 - PLAYER_HEIGHT / 2,\
                dy: 0\
            \};\
            pipes = []; // Resetta i tubi\
            score = 0;\
            lives = 3; // Resetta le vite a 3 all'inizio di una nuova partita\
            currentLevel = 1;\
            \
            // Imposta le velocit\'e0 dinamiche per il Livello 1\
            currentGravity = BASE_GRAVITY * GAME_OVERALL_SLOWDOWN_FACTOR;\
            currentFlapStrength = BASE_FLAP_STRENGTH * GAME_OVERALL_SLOWDOWN_FACTOR;\
            currentPipeSpeed = BASE_PIPE_SPEED * GAME_OVERALL_SLOWDOWN_FACTOR;\
            currentStarScrollSpeed = currentPipeSpeed / 2;\
            currentPinkGhostSpeed = BASE_PINK_GHOST_SPEED * GAME_OVERALL_SLOWDOWN_FACTOR;\
\
            scoreElem.textContent = `Punti: $\{score\} / $\{LEVEL_GOALS[currentLevel - 1]\} (Livello $\{currentLevel\}) Vite: $\{lives\}`;\
            currentPipeColor = PIPE_COLORS_PALETTE[Math.floor(Math.random() * PIPE_COLORS_PALETTE.length)];\
\
            pinkGhost.activated = false;\
            hearts = [];\
            childGhosts = [];\
            winMessageDelayTimer = null;\
            lastPipeTime = 0; // Resetta lastPipeTime in modo che il primo tubo venga generato dopo il flap\
\
            gameStatus = GAME_STATE.PENDING_START;\
            messageText.textContent = "Premi 'F' o tocca lo schermo per iniziare!"; // Messaggio di inizio generale\
            startButton.textContent = "Pronto!";\
            startButton.disabled = false; \
            messageBox.style.display = 'flex';\
\
            if (animationFrameId) \{\
                cancelAnimationFrame(animationFrameId);\
            \}\
            gameLoop();\
        \}\
\
        /**\
         * Resetta il livello corrente (posizione giocatore/pipes) ma mantiene score/vite.\
         */\
        function resetLevelForContinue() \{\
            player = \{\
                x: 50,\
                y: CANVAS_HEIGHT / 2 - PLAYER_HEIGHT / 2,\
                dy: 0\
            \};\
            pipes = []; // Resetta i tubi\
            score = 0; // Il punteggio si azzera per livello\
            \
            // Calcola i moltiplicatori di velocit\'e0 per il livello attuale\
            let levelMultiplier = 1;\
            if (currentLevel === 2) \{\
                levelMultiplier = LEVEL_SPEED_INCREASE_FACTOR;\
            \} else if (currentLevel === 3) \{\
                levelMultiplier = LEVEL_SPEED_INCREASE_FACTOR * LEVEL_SPEED_INCREASE_FACTOR;\
            \}\
\
            currentGravity = BASE_GRAVITY * GAME_OVERALL_SLOWDOWN_FACTOR * levelMultiplier;\
            currentFlapStrength = BASE_FLAP_STRENGTH * GAME_OVERALL_SLOWDOWN_FACTOR * levelMultiplier;\
            currentPipeSpeed = BASE_PIPE_SPEED * GAME_OVERALL_SLOWDOWN_FACTOR * levelMultiplier;\
            currentStarScrollSpeed = currentPipeSpeed / 2;\
            currentPinkGhostSpeed = BASE_PINK_GHOST_SPEED * GAME_OVERALL_SLOWDOWN_FACTOR * levelMultiplier;\
\
            scoreElem.textContent = `Punti: $\{score\} / $\{LEVEL_GOALS[currentLevel - 1]\} (Livello $\{currentLevel\}) Vite: $\{lives\}`;\
            currentPipeColor = PIPE_COLORS_PALETTE[Math.floor(Math.random() * PIPE_COLORS_PALETTE.length)];\
\
            pinkGhost.activated = false;\
            hearts = [];\
            childGhosts = [];\
            winMessageDelayTimer = null;\
            lastPipeTime = 0; // Resetta lastPipeTime in modo che il primo tubo venga generato dopo il flap\
\
            gameStatus = GAME_STATE.PENDING_START;\
            messageText.textContent = `Premi 'F' o tocca lo schermo per iniziare il Livello $\{currentLevel\}!`; // Messaggio specifico per l'inizio/riavvio del livello\
            startButton.textContent = "Pronto!";\
            startButton.disabled = false;\
            messageBox.style.display = 'flex';\
            \
            if (animationFrameId) \{\
                cancelAnimationFrame(animationFrameId);\
            \}\
            gameLoop();\
        \}\
\
\
        /**\
         * Termina il gioco e mostra un messaggio.\
         * @param \{string\} status - Lo stato finale del gioco ('gameOver', 'levelWin', o 'finalWin').\
         */\
        function endGame(status) \{\
            pipes = []; // Rimuovi immediatamente tutti i tubi dallo schermo!\
            hearts = [];\
            for (let i = 0; i < 50; i++) \{\
                hearts.push(createHeart());\
            \}\
\
            messageBox.style.display = 'none'; // Nascondi la messageBox all'inizio dell'animazione\
            startButton.disabled = true; // Disabilita il pulsante durante l'animazione/conto alla rovescia\
            startButton.textContent = "Attendere...";\
\
            const centerX = CANVAS_WIDTH / 2 - PLAYER_WIDTH / 2;\
            const centerY = CANVAS_HEIGHT / 2 - PLAYER_HEIGHT / 2;\
            // Il fantasma rosa si fermer\'e0 alla DESTRA del fantasma rosso\
            const pinkGhostTargetX = centerX + PLAYER_WIDTH + 5; \
\
            if (status === 'levelWin') \{\
                currentLevel++; // Incrementa il livello per la prossima giocata\
                score = 0; // Azzerare il punteggio per il nuovo livello\
                scoreElem.textContent = `Punti: $\{score\} / $\{LEVEL_GOALS[currentLevel - 1]\} (Livello $\{currentLevel\}) Vite: $\{lives\}`; // Aggiorna la visualizzazione del punteggio immediatamente\
                gameStatus = GAME_STATE.LEVEL_WIN_ANIMATION;\
                // Posizione iniziale per l'animazione del fantasma rosa per la vittoria di livello\
                pinkGhost.x = CANVAS_WIDTH + PLAYER_WIDTH; // Inizia dall'estrema destra\
                pinkGhost.y = centerY;\
                pinkGhost.activated = false; // Sar\'e0 true quando raggiunger\'e0 la destinazione\
                childGhosts = []; // Nessun fantasma figlio per la vittoria di livello\
                // Il testo del messaggio sar\'e0 impostato in updateWinScreen\
            \} else if (status === 'finalWin') \{\
                gameStatus = GAME_STATE.FINAL_WIN_ANIMATION;\
                // Punto di ingresso del fantasma rosa per l'animazione di vittoria finale\
                pinkGhost.x = CANVAS_WIDTH + PLAYER_WIDTH; // Inizia dall'estrema destra\
                pinkGhost.y = centerY;\
                pinkGhost.activated = false;\
                \
                // Fantasmi figli per l'animazione di vittoria finale\
                childGhosts = [\
                    \{ \
                        x: CANVAS_WIDTH + PLAYER_WIDTH + 50, // Inizia 50px a destra del pink ghost iniziale\
                        y: centerY + PLAYER_HEIGHT * 0.2, \
                        color: '#e53e3e', \
                        speed: currentPinkGhostSpeed * 0.8,\
                        targetX: pinkGhostTargetX + PLAYER_WIDTH * CHILD_GHOST_SIZE_FACTOR * 1.5, // Target a destra del fantasma rosa finale\
                        timeOffset: 0 \
                    \}, \
                    \{ \
                        x: CANVAS_WIDTH + PLAYER_WIDTH + 100, // Inizia 100px a destra del pink ghost iniziale\
                        y: centerY - PLAYER_HEIGHT * 0.2, \
                        color: '#ff69b4', \
                        speed: currentPinkGhostSpeed * 0.8, \
                        targetX: pinkGhostTargetX + PLAYER_WIDTH * CHILD_GHOST_SIZE_FACTOR * 0.5, // Target a destra del fantasma rosa finale\
                        timeOffset: Math.PI \
                    \} \
                ];\
\
            \} else if (status === 'gameOver') \{ // Il giocatore ha colpito un ostacolo\
                lives--;\
                scoreElem.textContent = `Punti: $\{score\} / $\{LEVEL_GOALS[currentLevel - 1]\} (Livello $\{currentLevel\}) Vite: $\{lives\}`;\
                \
                if (lives > 0) \{\
                    gameStatus = GAME_STATE.GAME_OVER_MESSAGE; // Pausa e richiesta di continuare\
                    messageText.textContent = `Hai perso una vita! Ti restano $\{lives\} vite. Premi 'F' o tocca per continuare.`;\
                    startButton.textContent = "Continua"; // Testo del pulsante\
                    startButton.disabled = false; // Abilita il pulsante\
                    messageBox.style.display = 'flex'; // Mostra la casella del messaggio\
                \} else \{ // Tutte le vite perse\
                    gameStatus = GAME_STATE.RESTART_COUNTDOWN; // Avvia il conto alla rovescia per il riavvio automatico\
                    messageText.textContent = `Game Over! Punti: $\{score\}. Non ti restano vite. Riavvio in 3...`;\
                    startButton.textContent = "Riavvio in 3...";\
                    startButton.disabled = true; // Il pulsante rimane disabilitato durante il conto alla rovescia\
\
                    let countdown = 3;\
                    const countdownInterval = setInterval(() => \{\
                        countdown--;\
                        if (countdown > 0) \{\
                            startButton.textContent = `Riavvio in $\{countdown\}...`;\
                        \} else \{\
                            clearInterval(countdownInterval);\
                            resetGameForNewPlay(); // Riavvia completamente il gioco dal Livello 1\
                        \}\
                    \}, 1000);\
                \}\
            \}\
        \}\
\
        // Listener di eventi per l'azione di "flap" (click, touch, tasto 'f')\
        function flap() \{\
            if (gameStatus === GAME_STATE.PENDING_START) \{\
                gameStatus = GAME_STATE.PLAYING;\
                messageBox.style.display = 'none';\
                player.dy = currentFlapStrength; // Applica il flap iniziale\
                lastPipeTime = Date.now(); // Inizia a generare i tubi\
            \} else if (gameStatus === GAME_STATE.GAME_OVER_MESSAGE) \{\
                // Se l'utente preme il tasto di flap mentre viene mostrato il messaggio 'hai perso una vita',\
                // attiva il reset del livello e attendi un nuovo flap.\
                resetLevelForContinue(); \
            \} else if (gameStatus === GAME_STATE.PLAYING) \{\
                // Flap normale durante il gameplay\
                player.dy = currentFlapStrength;\
            \}\
            // Altri stati (IDLE, animazioni, conto alla rovescia) non rispondono al flap direttamente a PLAYING.\
        \}\
\
        // Listener di eventi per click e touch per il flap\
        canvas.addEventListener('click', flap);\
        canvas.addEventListener('touchstart', (e) => \{\
            e.preventDefault(); // Impedisce lo scrolling sui dispositivi touch\
            flap();\
        \}, \{ passive: false \}); // 'passive: false' \'e8 necessario per e.preventDefault() in touchstart\
\
        // Listener di eventi per il tasto della tastiera 'f'\
        document.addEventListener('keydown', (e) => \{\
            if (e.key === 'f') \{\
                flap();\
            \}\
        \});\
\
        // Listener per il pulsante "Inizia Gioco" / "Continua" / "Gioca di nuovo" / "Prossimo Livello"\
        startButton.addEventListener('click', () => \{\
            // Questo pulsante ora serve solo a "preparare" il gioco/livello, non a farlo partire immediatamente\
            if (gameStatus === GAME_STATE.IDLE || gameStatus === GAME_STATE.FINAL_WIN_ANIMATION) \{\
                resetGameForNewPlay(); // Riavvio completo del gioco\
            \} else if (gameStatus === GAME_STATE.GAME_OVER_MESSAGE || gameStatus === GAME_STATE.LEVEL_WIN_ANIMATION) \{\
                resetLevelForContinue(); // Continua dal livello corrente\
            \}\
            // Dopo questo, il gameStatus sar\'e0 PENDING_START e attender\'e0 un flap\
        \});\
\
        /**\
         * Inizializza la configurazione del gioco.\
         */\
        function initGame() \{\
            canvas.width = CANVAS_WIDTH;\
            canvas.height = CANVAS_HEIGHT;\
            generateStars(); // Genera le stelle una volta all'inizio\
\
            // Inizializza le velocit\'e0 per lo stato iniziale/livello 1\
            currentGravity = BASE_GRAVITY * GAME_OVERALL_SLOWDOWN_FACTOR;\
            currentFlapStrength = BASE_FLAP_STRENGTH * GAME_OVERALL_SLOWDOWN_FACTOR;\
            currentPipeSpeed = BASE_PIPE_SPEED * GAME_OVERALL_SLOWDOWN_FACTOR;\
            currentStarScrollSpeed = currentPipeSpeed / 2;\
            currentPinkGhostSpeed = BASE_PINK_GHOST_SPEED * GAME_OVERALL_SLOWDOWN_FACTOR;\
\
            messageText.textContent = "Benvenuto a Flappy Fantasma! Premi 'Inizia Gioco' per prepararti.";\
            startButton.textContent = "Inizia Gioco";\
            messageBox.style.display = 'flex';\
            \
            // Inizializza il colore dei tubi per la schermata iniziale prima che il gioco inizi\
            currentPipeColor = PIPE_COLORS_PALETTE[Math.floor(Math.random() * PIPE_COLORS_PALETTE.length)];\
            \
            gameStatus = GAME_STATE.IDLE; // Stato iniziale\
            gameLoop(); // Avvia il gameLoop per disegnare la schermata iniziale\
        \}\
\
        // Inizializza il gioco quando la finestra viene caricata\
        window.onload = initGame;\
\
    </script>\
</body>\
</html>\
}